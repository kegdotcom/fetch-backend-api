1. Why did you choose the tools, libraries, and language you used for the coding exercise?:
For this project, I chose to use JavaScript to build the API. I chose JavaScript because of its native JSON support, which made it easy to process incoming data and properly format JSON responses. Additionally, JavaScript's async/await structure allows for great control over asynchronous operations, allowing me to easily optimize and sequence multiple database requests. Furthermore, I have lots of experience building applications in JavaScript, and I feel confident in my ability to build a project with it.
For handling HTTP requests, I chose to use Express.js. This was an obvious choice, as Express has built-in middleware to handle JSON data, making it even more fluid for data to go from the request to the database. Additionally, Express streamlines the process of setting up route handlers, which results in less boilerplate and more readable code.
Finally, I chose to use MongoDB Atlas for the database for this project. MongoDB Atlas is a NoSQL database service that follows a document-oriented structure. These documents are stored in a BSON format, which is very similar to JSON, again making it easier to pass data from the request to the database to interact. Additionally, most of the queries to MongoDB Atlas are in a JSON format, which also makes it simpler to query the database using data from the requests. Furthermore, not only is MongoDB free, but it also has built-in support for Node.js, so we can query the database without any additional setup. Finally, because MongoDB is a cloud-based database service, it makes it easy to share the program with recruiters and engineers at Fetch.

2. What are the advantages and disadvantages of your solution?:
One advantage of my solution are that when calculating which transactions to spend points from, the program will use a cursor, so that we only fully query the transactions we are using, and once we have spent all the points, we don't have to wait for all of the transaction queries to finish before moving on. Additionally, the program allows for an easy setup/install process, only needing one environment variable and two commands to be run in order to fully start the program. Another big advantage is that all langauges, tools, and frameworks used in this project natively support JSON, so the data processing is kept to a minimal. Finally, for any POST requests, my program validates the request body to make sure that all expected data was recieved, minimizing faulty requests.
However, there are two main disadvantages of my solution. One disadvantage is that the bundle size could be smaller. I chose to use Express in my project for the ease of use, but if I had instead used a more lightweight package, such as http, the bundle size could be reduced. The other main disadvantage to my solution is that we do not store old transactions. While this is also a good thing, because we don't have to store as much data in our database, it also means that we have no way to go back and view/analyze historical transaction data, which could have been useful for business decision-making.

3. What has been a favorite school/personal project thus far? What about it that challenged you?:
My favorite personal project I have done thus far is called DJ Buddy. It is a React application that allows a user to log in with their Spotify account, describe a playlist in a text box, and then process that text into a list of songs and actually add the playlist to the user's account. Additionally, it lets you see your Spotify Wrapped metrics anytime. Under the hood, this project uses the OAuth2 authentication flow to allow a user to connect their Spotify account. Then, OpenAI's Completions API uses a Large Language Model (GPT-3.5 Turbo) to process the user's input into a sentiment, and then into a list of song names. Then, the list of songs is put through Spotify's search engine and transformed into a list of Song objects, which can then be processed and added to a Spotify playlist in the user's account via the Spotify Web API. This was my favorite project to work on because not only do I use it regularly, but so do many of my friends. One of the best feelings as a developer is seeing other people enjoying a project you created, and so this was a project I was extremely proud of. Furthermore, this functionality ended up becoming a built-in Spotify feature a few months later, which was really cool to see.
But, that pride did not come right away. When I started DJ Buddy, I knew very little about authentication, HTTP requests, and APIs in general. As I worked on it, I struggled for a few weeks to get the project working. After a few months, though, I was able to accumulate lots of resources, from online tutorials, to books, to mentors, in order to learn the tools I needed for the project. However, because I was able to put these new skills into practice right away, I was able to grow a ton as a developer. I have never done a project that tought me so much, and I feel confident that making DJ Buddy made me a better programmer. Not only that, but I also got much better at learning new programming concepts. After months of work, trying to learn new paradigms, languages, and tools, I believe I not only became a better developer, but also a better learner. I began to figure out the methods that work best for me, and now I am much better at picking up and learning new concepts.
Overall, DJ Buddy was a project that tought me a ton about network requests, data processing, and authentication. It was a tool that I wanted to be able to use myself, and I was able to bring it to life and share it with others, which made me extremely happy. Additionally, it helped me sharpen my skills and begin to master web development, so I have to say that DJ Buddy is my favorite project I have worked on so far.